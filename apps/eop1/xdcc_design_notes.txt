# Steps

  1. Message flow trace: sniffer output  [DONE]
  2. Ingestor for message flow trace: outputs XML for draw.io
  3. Document draw.io conventions (see earlier text) [DONE]
  4. Sample design spec following conventions: Ingest, edit, and save sample output XML
     - components, message flows, message structs, component annotations, message annotations, associated CLE-JSON
  5. C libraries for AMQ and HAL [DONE]
  6. XDCC Code Generator: generate annotated xdcc
     - needs to signal conflicts in design 
     - needs to produce topology.json for divvier
  7. Integrate design GUI into CVI
     - See https://code.visualstudio.com/api/extension-guides/webview
  8. Setup CVI pipeline to handle partitioning of XDCC and test e2e over HAL
     - preferably without modifying tools from what was used at ERI summit!
  9. Stretch demo application

## Immediate Items:

 1. Specify functions that would take in JSON sample/schema and provides GEDL-firendly RPC-wrappable echo function
    - Try to fit within existing RPC generator marshalling capability 
    - GEDL does not handle structs or varags for parameters
 2. Specify functions that would take in stringified JSON (from AMQ) and extract arguments echo function
 3. Specify functions that would take in arguments of echo function and assemble stringified JSON (for posting to AMQ)


=============================
json FOO = [{"ID":1, "x":6.7, "y": 7.2, "z":3.4}, ...]


echo_FOO(ID[], x[], y[], z[]) -- GEDL friendly

myfunc(struct foo[])        -- not GEDL friendly
 where foo {ID,x,y,z}


RELATIONAL TABLE FOO
int col1 | double col2 | double col3 | double col4 ...


Need to generate the following given sample JSON messages from sniffer

void echo_FOO (int count, int col1[], double col2[], ...) {  // XXX:1

  // XXX: 2 generate code that produces FOO from arguments passed in to this function
  // basically invert ORM, this step may need a schema for FOO datatype

  ... insert FOO to AMQ ...
}

// XXX: 3 generate code that
// given FOO, extracts arguments for echo_FOO into local variables and invokes echo_FOO with those variables as arguments
=============================



----------------------------------------------------------------------------------------------------------------------------------

# Design of the XDCC Skeleton

// ----------------------------------------------------
// Unpartitioned
// ----------------------------------------------------

// There will be separate versions of each <func>_<MSG>() for each MSG such as updateMissionPlan, pnt, etc.
// These provide separate code paths for each MSG suitable for CLE annotation
// After partitioning echo_MSG will be distributed between the two enclaves, and may be RPC wrapped
// non_local(MSG) will always return false in unpartitioned program, but will return true for some in partitioned program

#define non_local(X) false

echo_MSG(m) 
  amqlib_publish(MSG,m)

egress_MSG(m)
  if non_local(MSG) 
     echo_MSG(m) 

main:
  foreach MSG in all_message_list: 
    setup_amq_listener_MSG(egress_MSG)    // amqlib_create, amqlib_listen
  // housekeep threads before exit

// ----------------------------------------------------
// Partitioned 
// ----------------------------------------------------

// echo_MSG will be distributed to master and slave
// for non_local
//    master receives from AMQ broker and relays to XDC peer (RPC over diode)
//    echo_MSG becomes _rpc_echo_MSG

// ----------------------------------------------------
// Master 
// ----------------------------------------------------

// #undef non_local(MSG) 
// non_local(MSG) function is autogenerated, will return true for remote messages

// includes main, master_thread_MSG, and egress_MSG unmodified for local messages
// includes echo_MSG unmodified only for local messages, omitted for remote messages
// there will be no echo_MSG on this side for remote messages
// for remote messages egress_MSG will be modified and _rpc_echo_MSG will be generated

egress_MSG(m)
  if non_local(MSG) 
     _rpc_echo_MSG(m) 

_rpc_echo_MSG(m):
  // marshalling
  x = jsonstr2idl(MSG,m) // packing/unpacking marshalling/unmarshalling
  xdc_async_send(x)

// ----------------------------------------------------
// Client
// ----------------------------------------------------

// includes echo_MSG unmodified for remote messages
// main, slave_rpc_loop, and handle_echo_MSG are generated

handle_echo_MSG(x)
  xdc_blocking_recv(x)
  m = idl2jsonstr(MSG,x) // packing/unpacking marshalling/unmarshalling
  echo_MSG(m)

slave_rpc_loop():
  foreach MSG in remote list:
    thread(handle_echo_MSG)

  // housekeeping on thread join

main:
  slave_rpc_loop()
  
//////////////////////////
option 1

const char * s = echo_component_heartbeats_cpp(comp,state);
amqlib_publish(...);

option 2:
echo_component_heartbeats(amq,comp,state);
//  you cast amq to AMQManager and publish to it
// #include amqmanager.h from NGC
// AMQManager *amq = static_cast<AMQMAnager *>(amq->obj);
// amq->publish(json ...)o


// in xdcc skeleton
egress_components_heartbeat(const char *s) {
  ...
  const char * ss[20]; //autogenerated
  const char * st[20]; //autogenerated
  unmarshal_component_heartbeats(s, ss, st); // C++ code in library, fills ss and st which are output parameters
  echo_component_heartbeats(ss,st); // here ss and st are input parameters
}
  
from amqmanager XDCC gets JSON 
convert to C string and calls egress_ ...
egress functions pull parameters out 
call echo // if local nothing will happen
          //gets rpc wrapped and becomes _rpc_echo
          // _rpc_echo is autogenerated by classic CLOSURE

other side gets HAL message, unpacks, calls echo
echo calls C++ library to jsonify and publish on AMQ on remote sides

Action items:
1. Move amq() into amqlib
2. Modify code generator to create unmarhsal functions with pure C signature
3. Generate xdcc-skeleton from code generator

=======================================

AMQManager is in C++, written by NGC, and calls ActiveMQ Artemis C++ API; this is a couple of cpp+hpp, calls system installed ActiveMQ library
JSON is in C++, open-source by nlohmann; single hpp

(I include these in amqlib but they can come from TA3 app also).

We need C code
We need distinct code paths to handle distinct messages

amqlib is a library that presents C functions, but is implemented in C++, calls AMQManager
  -- fixed code

echo   is a library that presents C functions, but is implemented in C++, calls JSON (also AMQManager for efficiency)
  -- autogenerated based on design GUI spec (currently a CSV standin)
xdcc.c is the autogenerated, annotated, partitionable component, suitable for CLOSURE toolchain
  -- calls echo and amqlib

xdcc-skeleton is an initial hand-made partial sketch to motivate xdcc.c
notes from friday explain what xdcc should look like, and how annotations will apply -- not fully worked out

=======================================
Note that we will need to handle one-way, because TA3 application is asynchronous and return messages are not allowed by policy

int get_ewma(double x)

   REQUEST_GET_EWMA {
    double x;
    //trailer
   }

   RESPONSE_GET_EWMA {  // needed if synchronous, not allowed if one-way!
    int ret;
    //trailer
   }

master side, rewrite
_rpc_get_ewma(double x)
  pack x into REQUEST_GET_EWMA 
  send REQUEST_GET_EWMA 
  block, waiting for RESPONSE_GET_EWMA   //XXX: if one-way nothing comes back!!
                                         // suppress if one way
  unpack into output args if any and return value and return //return void if one-way

client slave loop
handle_get_ewma
   wait for REQUEST_GET_EWMA
   unpack REQUEST_GET_EWMA into vars // x
   call get_ewma with vars // x
   get return value
   pack return value into RESPONSE_GET_EWMA // suppress if one-way
   send RESPONSE_GET_EWMA // suppress if one-way
   return
   
on master
  _rpc_get_ewma is a synchronous call // control does not proceed until response is received and block returns

====
Test Notes

1. Test in emulator requires both ingress_xdcc and egress_xdcc as well as the application components ; cannot be part of either project (parent project needed to orchestrate all child projects)
2. AMQ Broker needs to be installed, configured, and started in each enclave
3. amqlib needs to be installed in each enclave; also must be in LD_LIBRARY_PATH
4. Need a producer and a consumer
   -- either use activemq producer with a file (and activemq consumer)
5. Use TA3 messages (remove int k) and use TA3 components and test

